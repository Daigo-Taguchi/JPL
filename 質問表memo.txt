Java質問メモ

2章
2.1.2 P37
「publicクラスにはクラスと同じ名前のファイルの中に書かれなければならない」
同じファイルとはどこのファイルのことを言っているのか？

2.1.2 P37 練習問題2.2
LinkedListクラスの中で次のLinkedList要素への参照を持つというのは、LinkedList型の変数をクラス内で持たせればいいのか？
Listは使わない？

2.4 P42 
練習問題2.5と2.6のコード確認してほしい

2.6 P51 (L18-19)
オブジェクトのtoStringの場合はなぜ特殊なのか。このあたりの開設が欲しい。
練習問題2.10の解答も見てほしい。

2.6.3 P52 (L28-30)
"コンパイラーがシーケンスパラメータを見つけると残りの引数すべてをシーケンスパラメータで指定された型の配列にまとめてしまいます。"
が分からない。

2.6.5 P56 (L20-21)
引数にfinalを明示することでパラメータと同じ名前のフィールドに代入することを意図するの意味がわからない

2.6.6 P58 練習問題2.13 (L30)
javaではgetterとsetterの名前は変数と同じく最初が小文字で区切りが大文字でいいのか

2.8 P61 練習問題2.17 (L34)
TRURN_LEFTもしくはTRUN_RIGHTを引数で指定するメソッドのオーバーロードの書き方がわからない。


==========================================================================================================================================
第4回 8/31質問分

practice2.14
Practice2.13のVehicleをimportしてLinkedlListクラスを作成している。
Vehicleクラス単体では狙い通りに動作しているように見える。
しかし、LinkedListクラスを動作させると、nextIDが1ズレる。なぜか。

practice2.17
turn()はどうやってオーバーロードで区別するのかもう一度教えてほしい。


3.1 P66 (L25-30)
SetValueメソッドの返り値でoldValueを返しているのはどんな意図があるのか。voidではだめなのか。

3.2 P72(L9)
・オブジェクトの本当の型とは何か。
・maskメソッドには引数origが必要だが、この説明では引数に何を使用することを想定しているのか。

3.2 P72 練習問題3.2,3.3が分からない

3.3 P75(L32)
Supershow sup にはExtendShowのインスタンスが代入されているので、sup.showでExtendshowのshow()が呼び出される。
しかし、なぜsup.strとするとExtendShowのstrが呼び出されずに、SuperShowのstrが呼び出されるのか。

=========================================================================================================================================
第5回 9/6質問分
3.7 P84 (L22-23)
この例で言うと、今回はbenchMarkメソッドが何もしないメソッドだが、他にBenchMarkクラスを継承したクラスが存在して、その中にbenchMarkメソッドの内容を定義してあるとしても、
superクラスであるBenchMarkクラスには影響しないという利点がある。BenchMarkクラスの責務としては、
repeatメソッドの中で何かのメソッド(benchMarkメソッド)を繰り返し呼び出して、その処理にかかる時間を計測するだけなので、benchMarkメソッドの内容はどうでもいいという解釈でよいか。

3.7 P86 practice3.5(L2)
・MethodBenchmarkクラスはコマンドライン引数を使ってるのでコマンドラインからコンパイルして実行しようとしたらコンパイルできない。
・「0からパラメータとして渡された値までループする」の意味が分からない

3.7 P86 practice3.6(L4)
Vehicleを変更してコンストラクタでEnergySourceのオブジェクトの参照を持つようにするとはどういうことか

3.8 P87 practice3.7(L34)
ColorAttrクラスの中のScreenColor型が定義されてないから進められなかった。


3.9 P91 (L21-23)
拡張したクラスによるsuper.cloneの呼び出しが拡張した型の正しいオブジェクトではなく、IntegerStackオブジェクトを返すことになります。super.cloneからの戻り値はIneterStack参照にキャストされてます。
の部分の解説が欲しい。

3.9 P91(L27-28)
Objectクラスのcloneメソッドはフィールドの値をすべてコピーするが、配列のコピーは行わないということか？

3.9 P92(L4)
複製元と複製先で共有されるべきでないオブジェクトが配列でない場合の意味が分からない

3.9 P92(L14-16)
サブクラスが誤って不正な状態のオブジェクトをcloneにより決して生成しないように例外を投げるようにする、ということが分からない。

=========================================================================================================================================
4.3 P108(L5-6)
インターフェースを継承してメソッドをオーバーライドするってことは、まったく同じ名前、同じシグニチャのメソッドが定義されているってことか。
(本当に意味なくない？なんでできるの？？)

4.4 P109(L9-16)
ここの説明のイメージがつかないので解説がほしい。

4.4 P109(L34-35)
パラメータと戻り値の防御的コピーとは何か

4.4 P109 (L36-)
この部分の解説がほしい。

4.4 P111 (L22-25)
attrs()の戻り値と同じものをiterator()で返すならなぜIterableインターフェースを実装したのか

==========================================================================================================================================
5.1 P116(L2-3)
enclosingクラスがprivateだとその中のインターフェースはprivateになるのか、それともエラーになるのか。

5.2.2 P121(L6-)
内部クラスの円クロージングクラスがOuterのサブクラスでない場合にsuperを通してInnerのコンストラクタを呼び出す際に、
Outerオブジェクトへの参照を提供しなければならないとあるが、例のref.super()と表記した場合、Outerクラスの基底クラスのコンストラクタが存在したら
呼ばれてしまわないのか。これでInnerクラスのコンストラクタが呼ばれるのか。

5.2.2 P121(L29-)
説明したように〜〜から始まる部分が分からない。

5.2.3 P122(L1)
内部クラスはエンクロージングクラスのメンバーに直接アクセスできるが、限定的なthisを使って普段からアクセスするのが良いのか。


5.3 P123(L20-)
唯一の制限はローカル変数、メソッドパラメータはfinalと宣言されている場合のみアクセスできる。とあるが、2行
上にあるように、クラスが定義されているスコープ内の変数すべてにアクセスできるわけじゃないのか？

5.3 P124(L37-38)
ローカル内部クラスでは一旦ローカル変数やパラメータが隠ぺいされてしまうとそれらを参照することができなくなるとあるが、
具体的に何にアクセスできなくなるか分からない。メソッドのブロック内のローカル変数などにアクセスできなくなるということか？
===============================================================================================================================================
6.3.1(L5-)
いまいちenumのコンストラクターのイメージがわかないので説明がほしい。

6.3 P135(L5-7)
「privateコンストラクタはenum型が直接インスタンス化できないことを保証している」の意味が分からない。

6.3 P135(L10)
enumコンストラクタ→staticフィールドのコンストラクタの順番で初期化されるから、enumコンストラクタでstaticフィールドを参照できない
という解釈でよいか

6.3.2 P137(L8-)
「各enum定数に対して定義されているクラスは実質的にenum型を継承している無名内部クラス」とあるが、どのクラスのことを言っているのか。

6.4 P137(L26-)
2つめの箇条書き。オーバーライドされてfinalと宣言されてるとどうなるのか。
===============================================================================================================================================
7.1.1 P141(L19)
0x10ffffがなんで21ビット文字か分からない

7.5 P157(L19)
ローカル変数は内部クラスを隠蔽できるという意味が分からない

8.1 P159(L9)
ボクシング変換の例が分からない

8.1 P159(L6)
ラッパークラスByte,ShortのラッパークラスはNumberで、NumberのラッパークラスはOblectになるのか

=================================================================================================================================================
11.0 P216(L23)
Queueを表しているプログラムだが、2つ目以降のQueueの中身の処理はどうなるのか分からない。

11.1 P219(L14)
ジェネリックではコンパイラーは内部でキャストで処理しているということ？
ジェネリックを使用しなくても、キャストを代用して表現できるということか。

11.1 P219(L22)(練習問題11.3)
Attrクラスをジェネリッククラスとして書くことで、Attrのvalueに宣言時に指定した型でしか更新できなくなる。
これはKey,Valueのデータ管理の観点から言うとよ良いか、悪いのかわからない。

11.1 P220(L15-)
extendsでインターフェースを指定しているところが分からない。
そもそもインターフェースをextendsできるのか？

11.2 P225(19)
例の中でのstrings.addしている部分がコンパイルされないのは、
addの定義で?を利用していて、Objectを継承している型としか定義していないので、何の型が入るか分からないから
こんぱいるが通らないという解釈であっているか