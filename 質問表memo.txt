Java質問メモ

2章
2.1.2 P37
「publicクラスにはクラスと同じ名前のファイルの中に書かれなければならない」
同じファイルとはどこのファイルのことを言っているのか？

2.1.2 P37 練習問題2.2
LinkedListクラスの中で次のLinkedList要素への参照を持つというのは、LinkedList型の変数をクラス内で持たせればいいのか？
Listは使わない？

2.4 P42 
練習問題2.5と2.6のコード確認してほしい

2.6 P51 (L18-19)
オブジェクトのtoStringの場合はなぜ特殊なのか。このあたりの開設が欲しい。
練習問題2.10の解答も見てほしい。

2.6.3 P52 (L28-30)
"コンパイラーがシーケンスパラメータを見つけると残りの引数すべてをシーケンスパラメータで指定された型の配列にまとめてしまいます。"
が分からない。

2.6.5 P56 (L20-21)
引数にfinalを明示することでパラメータと同じ名前のフィールドに代入することを意図するの意味がわからない

2.6.6 P58 練習問題2.13 (L30)
javaではgetterとsetterの名前は変数と同じく最初が小文字で区切りが大文字でいいのか

2.8 P61 練習問題2.17 (L34)
TRURN_LEFTもしくはTRUN_RIGHTを引数で指定するメソッドのオーバーロードの書き方がわからない。


==========================================================================================================================================
第4回 8/31質問分

practice2.14
Practice2.13のVehicleをimportしてLinkedlListクラスを作成している。
Vehicleクラス単体では狙い通りに動作しているように見える。
しかし、LinkedListクラスを動作させると、nextIDが1ズレる。なぜか。

practice2.17
turn()はどうやってオーバーロードで区別するのかもう一度教えてほしい。


3.1 P66 (L25-30)
SetValueメソッドの返り値でoldValueを返しているのはどんな意図があるのか。voidではだめなのか。

3.2 P72(L9)
・オブジェクトの本当の型とは何か。
・maskメソッドには引数origが必要だが、この説明では引数に何を使用することを想定しているのか。

3.2 P72 練習問題3.2,3.3が分からない

3.3 P75(L32)
Supershow sup にはExtendShowのインスタンスが代入されているので、sup.showでExtendshowのshow()が呼び出される。
しかし、なぜsup.strとするとExtendShowのstrが呼び出されずに、SuperShowのstrが呼び出されるのか。

=========================================================================================================================================
第5回 9/6質問分
3.7 P84 (L22-23)
この例で言うと、今回はbenchMarkメソッドが何もしないメソッドだが、他にBenchMarkクラスを継承したクラスが存在して、その中にbenchMarkメソッドの内容を定義してあるとしても、
superクラスであるBenchMarkクラスには影響しないという利点がある。BenchMarkクラスの責務としては、
repeatメソッドの中で何かのメソッド(benchMarkメソッド)を繰り返し呼び出して、その処理にかかる時間を計測するだけなので、benchMarkメソッドの内容はどうでもいいという解釈でよいか。

3.7 P86 practice3.5(L2)
・MethodBenchmarkクラスはコマンドライン引数を使ってるのでコマンドラインからコンパイルして実行しようとしたらコンパイルできない。
・「0からパラメータとして渡された値までループする」の意味が分からない

3.7 P86 practice3.6(L4)
Vehicleを変更してコンストラクタでEnergySourceのオブジェクトの参照を持つようにするとはどういうことか

3.8 P87 practice3.7(L34)
ColorAttrクラスの中のScreenColor型が定義されてないから進められなかった。


3.9 P91 (L21-23)
拡張したクラスによるsuper.cloneの呼び出しが拡張した型の正しいオブジェクトではなく、IntegerStackオブジェクトを返すことになります。super.cloneからの戻り値はIneterStack参照にキャストされてます。
の部分の解説が欲しい。

3.9 P91(L27-28)
Objectクラスのcloneメソッドはフィールドの値をすべてコピーするが、配列のコピーは行わないということか？

3.9 P92(L4)
複製元と複製先で共有されるべきでないオブジェクトが配列でない場合の意味が分からない

3.9 P92(L14-16)
サブクラスが誤って不正な状態のオブジェクトをcloneにより決して生成しないように例外を投げるようにする、ということが分からない。

=========================================================================================================================================
4.3 P108(L5-6)
インターフェースを継承してメソッドをオーバーライドするってことは、まったく同じ名前、同じシグニチャのメソッドが定義されているってことか。
(本当に意味なくない？なんでできるの？？)

4.4 P109(L9-16)
ここの説明のイメージがつかないので解説がほしい。

4.4 P109(L34-35)
パラメータと戻り値の防御的コピーとは何か

4.4 P109 (L36-)
この部分の解説がほしい。

4.4 P111 (L22-25)
attrs()の戻り値と同じものをiterator()で返すならなぜIterableインターフェースを実装したのか







